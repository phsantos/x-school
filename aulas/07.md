,<p align="center">
<a href="#">
<img width="400" src="https://github.com/3Tecnos-Development/mono/assets/5139981/ec6daa7c-9107-46ae-9389-1e20e93cca39">
</a>

</p>
<h1 align="center" style="color:purple">X-School</h1>

<h1 align="center">Curso de Desenvolvimento Full Stack com Node.js, React Native e Monorepo NX (DDD e SOLID)</h1>

<h1 align="center">API e DDD</h1>

### Aula 06

#### Application Service

√â um componente respons√°vel por orquestrar e coordenar as intera√ß√µes entre os objetos de dom√≠nio, as infraestruturas externas e as interfaces de usu√°rio. O objetivo principal de um Application Service √© expor opera√ß√µes de alto n√≠vel que representam casos de uso ou fluxos de trabalho espec√≠ficos da aplica√ß√£o.

O Application Service age como uma camada intermedi√°ria entre a interface do usu√°rio (ou outras fontes de entrada) e o n√∫cleo do dom√≠nio. Ele n√£o cont√©m l√≥gica de neg√≥cios complexa, mas coordena a execu√ß√£o das opera√ß√µes necess√°rias no dom√≠nio, garantindo que as regras de neg√≥cios sejam aplicadas corretamente e que as opera√ß√µes sejam realizadas em uma sequ√™ncia l√≥gica.

Caracter√≠sticas:

1. Coordena√ß√£o de Fluxo
   > [!NOTE] <span style="color:purple"> Um Application Service coordena a execu√ß√£o de opera√ß√µes de neg√≥cios que podem envolver v√°rias etapas e entidades. Ele decide a ordem em que as opera√ß√µes devem ser executadas e como elas se conectam entre si.
2. Tradu√ß√£o de Entradas
   > [!NOTE] <span style="color:purple"> O Application Service traduz os par√¢metros vindos das interfaces de usu√°rio ou outras fontes externas para objetos de dom√≠nio compreens√≠veis, preparando-os para o processamento pelo dom√≠nio.
3. Chamada de Servi√ßos de Dom√≠nio
   > [!NOTE] <span style="color:purple"> O Application Service chama m√©todos nos objetos de dom√≠nio apropriados para executar as opera√ß√µes. Ele tamb√©m pode ser respons√°vel por coordenar a colabora√ß√£o entre diferentes agregados.
4. Transa√ß√µes e Persist√™ncia
   > [!NOTE] <span style="color:purple"> O Application Service √© respons√°vel por gerenciar as transa√ß√µes, garantindo que as opera√ß√µes de neg√≥cios sejam executadas atomicamente e que as altera√ß√µes no estado do dom√≠nio sejam persistidas no armazenamento.
5. Tratamento de Erros
   > [!NOTE] <span style="color:purple"> O Application Service trata erros e exce√ß√µes que podem ocorrer durante a execu√ß√£o das opera√ß√µes. Ele decide como lidar com esses cen√°rios e pode desencadear a√ß√µes apropriadas, como notificar o usu√°rio ou reverter transa√ß√µes.
6. Exposi√ß√£o de Interface
   > [!NOTE] <span style="color:purple"> O Application Service fornece uma interface para as camadas externas, como interfaces de usu√°rio, servi√ßos web ou APIs, para que os casos de uso da aplica√ß√£o possam ser acionados.
7. Independ√™ncia Tecnol√≥gica
   > [!NOTE] <span style="color:purple"> O Application Service isola a l√≥gica de neg√≥cios do detalhe de implementa√ß√£o t√©cnica, permitindo que o dom√≠nio seja independente de frameworks e tecnologias.

##### Vejamos alguns exemplos:

üí° Service _CriarServidorService_

üí° Tipos/interfaces compartilhadas para o servi√ßo

```typescript
import domain from "x-school/domain";

export type CriarServidorInput = Omit<domain.servidor.ServidorProps, "id" | "createdAt"> & {
  cnpj: string;
};

export type CriarServidorOutput = {
  id: domain.servidor.ServidorId;
  createdAt: string;
};
```

```typescript
import { IApplicationService } from "@3tecnos/arch/application";
import { Injectable } from "@3tecnos/ioc";
import { throwIfNullable } from "@3tecnos/util";
import { EventBus } from "@3tecnos/events";
import { OperationConflictException } from "@3tecnos/exceptions";
import { CNPJ } from "@3tecnos/values";

import { servidorDTO } from "x-school/shared";
import domain from "x-school/domain";
import { ServidorRepository, UnidadeGestoraRepository } from "x-school/api/infra";

@Injectable()
export class CriarServidorService
  implements IApplicationService<servidorDTO.CriarServidorInput, servidorDTO.CriarServidorOutput>
{
  constructor(
    private readonly servidorRepository: ServidorRepository,
    private readonly unidadeGestoraRepository: UnidadeGestoraRepository,
    private eventBus: EventBus
  ) {}

  async handle(input: servidorDTO.CriarServidorInput): Promise<servidorDTO.CriarServidorOutput> {
    const cnpj = new CNPJ(input.cnpj);
    const unidadeGestora = await this.unidadeGestoraRepository.findBy(cnpj);
    throwIfNullable(unidadeGestora, OperationConflictException);
    const unidadeGestoraId = unidadeGestora.id.value;

    const servidor = domain.Servidor.criar({ ...input });

    await this.servidorRepository.withParentsIds(unidadeGestoraId).create(servidor);

    for (const event of servidor.domainEvents) {
      this.eventBus.emit(event);
    }

    return {
      id: servidor.id,
      createdAt: servidor.createdAt.value.toDateString(),
    };
  }
}
```

üí° Service _AssinarDocumentoService_

```typescript
import { OperationConflictException } from "@3tecnos/exceptions";
import { throwIfNullable } from "@3tecnos/util";
import { IApplicationService } from "@3tecnos/arch/application";
import { AssinaturaInput, DocGrid, PreviewInput } from "@3tecnos/docgrid";
import { Injectable } from "@3tecnos/ioc";
import {
  AssinantePrincipal,
  CategoriaRepository,
  ConfiguracaoDaAssinaturaRepository,
  DocumentoRepository,
  UnidadeGestoraRepository,
} from "assine-aqui-api/infra";
import { documentoDTO } from "assine-aqui/shared";
import domain from "assine-aqui/domain";
import { CNPJ, UF } from "@3tecnos/values";
import { Serializable } from "@3tecnos/serialization";

type AssinarDocumentoServiceInput = documentoDTO.AssinarDocumentoInput & { senha: string };
type DocGridAssinarInput = {
  itemDaCategoria: domain.itemDaCategoria.ItemDaCategoria;
  documento: domain.documento.Documento;
  assinatura: domain.documento.Assinatura;
  senha: string;
  cnpj: CNPJ;
  uf: UF;
};

const criarDocGridAssinarInput = ({
  itemDaCategoria,
  cnpj,
  uf,
  documento,
  assinatura,
  senha,
}: DocGridAssinarInput): AssinaturaInput => {
  const { relatorioPayload } = itemDaCategoria.export();

  return {
    uf: uf.value,
    cnpj: cnpj.value,
    ano: documento.emissao.value.getFullYear().toString(),
    autenticacao: documento.autenticacao?.value ?? "",
    keys: documento.keys,
    relatorioPayload,
    assinatura: {
      cpf: assinatura.cpf.value,
      nome: assinatura.nome.value,
      ordem: assinatura.ordem,
      createdAt: assinatura.createdAt.toUnixTimeStamp(),
    },
    certificadoDigital: {
      cpf: assinatura.cpf.value,
      senha,
    },
  } as AssinaturaInput;
};

@Serializable("ObWvqDHljOSOMuSsW0xse")
export class DocumentoNaoEncontradoException extends OperationConflictException {
  constructor() {
    super("Documento n√£o encontrado.");
  }
}

@Injectable()
export class AssinarDocumentoService
  implements IApplicationService<AssinarDocumentoServiceInput, domain.documento.DocumentoPreview>
{
  constructor(
    private readonly documentoRepository: DocumentoRepository,
    private readonly categoriaRepository: CategoriaRepository,
    private readonly configuracaoDaAssinaturaRepository: ConfiguracaoDaAssinaturaRepository,
    private readonly unidadeGestoraRepository: UnidadeGestoraRepository,
    private readonly principal: AssinantePrincipal,
    private readonly docGrid: DocGrid
  ) {}

  async handle({ documentoId, senha }: AssinarDocumentoServiceInput): Promise<domain.documento.DocumentoPreview> {
    const { cpf, cnpj } = this.principal.claims;

    const unidadeGestora = await this.unidadeGestoraRepository.findBy(cnpj);
    throwIfNullable(unidadeGestora, OperationConflictException);

    const documento = await this.documentoRepository
      .withParentsIds(unidadeGestora.id.value)
      .findById(documentoId.value);
    throwIfNullable(documento, DocumentoNaoEncontradoException);

    const configuracaoDaAssinatura = await this.configuracaoDaAssinaturaRepository
      .withParentsIds(unidadeGestora.id.value)
      .findBy(documento.itemDaCategoriaId);
    throwIfNullable(configuracaoDaAssinatura, OperationConflictException);

    const categoria = await this.categoriaRepository.findById(documento.categoriaId.value);
    throwIfNullable(categoria, OperationConflictException);

    const itemDaCategoria = categoria.obterItemDaCategoriaPorId(documento.itemDaCategoriaId.value);
    throwIfNullable(itemDaCategoria, OperationConflictException);

    const assinatura = documento.assinar({ configuracaoDaAssinatura, cpfDoAssinante: cpf });

    //Caso j√° exista esta assinatura no documento, o m√©todo assinar retorna nulo, prevenindo o erro de mandar assinar m√∫ltiplas vezes o mesmo documento.
    if (assinatura) {
      const assinarInput = criarDocGridAssinarInput({
        itemDaCategoria,
        cnpj: unidadeGestora.cnpj,
        uf: new UF(unidadeGestora.uf),
        documento,
        assinatura,
        senha,
      });

      await this.docGrid.assinar(assinarInput);

      await this.documentoRepository.modify(documento);
    }

    const previewInput = {
      uf: unidadeGestora.uf,
      cnpj: cnpj.value,
      ano: documento.emissao.value.getFullYear().toString(),
      keys: documento.keys,
      relatorioPayload: itemDaCategoria.relatorioPayload.export(),
    } as PreviewInput;
    const URL = documento.previewURL?.value ?? this.docGrid.generatePreviewURL(previewInput);

    return {
      URL,
      fileName: documento.nomeDoArquivo,
    };
  }
}
```

üí° Service _CriarFolhaDePagamentoService_

```typescript
import { IApplicationService } from "@3tecnos/arch/application";
import { EventBus } from "@3tecnos/events";
import { Injectable } from "@3tecnos/ioc";
import { throwIfNullable } from "@3tecnos/util";
import { CNPJ } from "@3tecnos/values";
import { FolhaDePagamentoRepository, UnidadeGestoraRepository, CategoriaDoTrabalhadorAdapter } from "siafic/api/infra";
import { FolhaDePagamento, UnidadeGestora } from "siafic/domain";
import { CriarFolhaDePagamentoInput, OperacaoDeCriarOutput } from "siafic/shared";
import { UnidadeGestoraNaoEncontradaException, CategoriaDoTrabalhadorNaoExisteException } from "../../../exceptions";

@Injectable()
export class CriarFolhaDePagamentoService
  implements IApplicationService<CriarFolhaDePagamentoInput, OperacaoDeCriarOutput>
{
  constructor(
    private unidadeGestoraRepository: UnidadeGestoraRepository<UnidadeGestora>,
    private folhaDePagamentoRepository: FolhaDePagamentoRepository<FolhaDePagamento>,
    private categoriaDoTrabalhadorAdapter: CategoriaDoTrabalhadorAdapter,
    private eventBus: EventBus
  ) {}

  async handle(props: CriarFolhaDePagamentoInput): Promise<OperacaoDeCriarOutput> {
    const unidadeGestoraCnpj = new CNPJ(props.cnpj);
    const unidadeGestora = await this.unidadeGestoraRepository.findBy(unidadeGestoraCnpj);
    throwIfNullable(unidadeGestora, UnidadeGestoraNaoEncontradaException);
    const unidadeGestoraId = unidadeGestora.id.value;

    const folhaDePagamento = FolhaDePagamento.criar({ ...props, unidadeGestoraId });

    if (folhaDePagamento.funcionario) {
      const categoriaDoTrabalhadorExists = this.categoriaDoTrabalhadorAdapter.exists(
        folhaDePagamento.funcionario.categoriaDoTrabalhador
      );
      if (!categoriaDoTrabalhadorExists) throw new CategoriaDoTrabalhadorNaoExisteException();
    }

    await this.folhaDePagamentoRepository.withParentsIds(unidadeGestoraId).create(folhaDePagamento);

    for (const event of folhaDePagamento.domainEvents) {
      this.eventBus.emit(event);
    }

    return {
      id: folhaDePagamento.id.value,
      createdAt: folhaDePagamento.createdAt.toISOString(),
    };
  }
}
```
