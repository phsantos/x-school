,<p align="center">
<a href="#">
<img width="400" src="https://github.com/3Tecnos-Development/mono/assets/5139981/ec6daa7c-9107-46ae-9389-1e20e93cca39">
</a>

</p>
<h1 align="center" style="color:purple">X-School</h1>

<h1 align="center">Curso de Desenvolvimento Full Stack com Node.js, React Native e Monorepo NX (DDD e SOLID)</h1>

<h1 align="center">API e DDD</h1>

### Aula 08

#### Query Handler (CQS)

Um Query Handler Ã© responsÃ¡vel por tratar as consultas feitas ao sistema. Ele recebe a consulta do cliente ou de uma parte do sistema e entÃ£o recupera os dados necessÃ¡rios do armazenamento (como um banco de dados) ou de outras fontes e os retorna em uma forma adequada para o cliente ou parte solicitante. O Query Handler lida com a complexidade de consultar vÃ¡rias fontes de dados, fazer junÃ§Ãµes de dados, aplicar filtros, ordenaÃ§Ãµes e outras operaÃ§Ãµes relacionadas Ã  leitura.

Os Query Handlers sÃ£o tipicamente implementados em uma camada separada daquela onde os comandos sÃ£o tratados, a fim de evitar misturar a lÃ³gica de leitura e a lÃ³gica de escrita. Essa separaÃ§Ã£o nÃ£o sÃ³ torna o cÃ³digo mais organizado, mas tambÃ©m facilita a manutenÃ§Ã£o, pois as mudanÃ§as nas operaÃ§Ãµes de leitura nÃ£o afetarÃ£o as operaÃ§Ãµes de escrita e vice-versa.

No contexto de um sistema seguindo o DDD, os Query Handlers sÃ£o uma parte importante para criar uma interface bem definida entre a camada de apresentaÃ§Ã£o (como Controllers em APIs) e a camada de domÃ­nio. Isso ajuda a garantir que a lÃ³gica de negÃ³cios seja mantida focada no domÃ­nio, enquanto a lÃ³gica de consulta possa ser tratada de forma mais especializada e flexÃ­vel no Query Handler.

CaracterÃ­sticas:

1. Leitura de Dados
   > [!NOTE] <span style="color:purple"> Query Handlers sÃ£o responsÃ¡veis por lidar com operaÃ§Ãµes de leitura, ou seja, consultas que nÃ£o alteram o estado do sistema, mas recuperam informaÃ§Ãµes.
2. SeparaÃ§Ã£o de Responsabilidades
   > [!NOTE] <span style="color:purple"> Eles promovem a separaÃ§Ã£o de responsabilidades entre a lÃ³gica de leitura (consultas) e a lÃ³gica de escrita (comandos), mantendo uma clara distinÃ§Ã£o entre as operaÃ§Ãµes.
3. Foco no DomÃ­nio
   > [!NOTE] <span style="color:purple"> Query Handlers permitem que a lÃ³gica de consulta seja tratada de forma especializada, enquanto a lÃ³gica de negÃ³cios se concentra no domÃ­nio e nas operaÃ§Ãµes que alteram o estado do sistema.
4. Camada de ApresentaÃ§Ã£o
   > [!NOTE] <span style="color:purple"> Camada de ApresentaÃ§Ã£o: SÃ£o frequentemente usados em camadas de apresentaÃ§Ã£o, como Controllers em arquiteturas de API, para receber solicitaÃ§Ãµes de clientes e retornar dados.
5. Modelagem de Dados
   > [!NOTE] <span style="color:purple"> Query Handlers podem ser usados para recuperar dados de vÃ¡rias fontes, como bancos de dados, serviÃ§os externos ou caches, e transformar esses dados em um formato adequado para o cliente.
6. OtimizaÃ§Ã£o de Consultas
   > [!NOTE] <span style="color:purple"> Eles podem realizar otimizaÃ§Ãµes de consulta para melhorar o desempenho, como a busca seletiva de dados, junÃ§Ãµes e ordenaÃ§Ãµes.
7. Caching
   > [!NOTE] <span style="color:purple"> Query Handlers podem implementar estratÃ©gias de caching para armazenar resultados de consulta frequentemente acessados e reduzir a carga em fontes de dados.
8. Filtros e OrdenaÃ§Ã£o
   > [!NOTE] <span style="color:purple"> Podem oferecer recursos de filtragem e ordenaÃ§Ã£o para permitir que os clientes solicitem dados especÃ­ficos.
9. ReutilizaÃ§Ã£o
   > [!NOTE] <span style="color:purple"> Com a separaÃ§Ã£o de responsabilidades, os Query Handlers podem ser reutilizados em diferentes partes do sistema que precisam das mesmas informaÃ§Ãµes.
10. Testabilidade
    > [!NOTE] <span style="color:purple"> A separaÃ§Ã£o entre operaÃ§Ãµes de leitura e escrita torna os Query Handlers mais fÃ¡ceis de testar, pois a lÃ³gica de consulta pode ser testada independentemente da lÃ³gica de negÃ³cios.
11. Escalabilidade
    > [!NOTE] <span style="color:purple"> A separaÃ§Ã£o de operaÃ§Ãµes de leitura e escrita tambÃ©m permite escalar as partes do sistema independentemente, jÃ¡ que a carga de leitura e a carga de escrita podem ser tratadas de maneira diferente.
12. ManutenÃ§Ã£o Simples
    > [!NOTE] <span style="color:purple"> AlteraÃ§Ãµes nos requisitos de leitura podem ser feitas de forma isolada, sem afetar a lÃ³gica de negÃ³cios ou outras partes do sistema.
13. DocumentaÃ§Ã£o Clara
    > [!NOTE] <span style="color:purple"> A estrutura de Query Handlers facilita a documentaÃ§Ã£o das consultas disponÃ­veis, tornando mais claro para os desenvolvedores quais dados podem ser solicitados.

##### Vejamos alguns exemplos:

ðŸ’¡ Query _DocumentosQueryHandler_

ðŸ’¡ Tipos/interfaces compartilhadas para a query

```typescript
import { FieldFilterExpression, FiltersRecord } from "@3tecnos/values";
import domain from "assine-aqui/domain";

export type Periodo = {
  inicio: Date;
  fim: Date;
};

export interface DocumentosFilters extends FiltersRecord {
  situacao: FieldFilterExpression<domain.documento.Situacao>;
  pendente: FieldFilterExpression<domain.documento.Pendente>;
  itemDaCategoriaId: FieldFilterExpression<domain.itemDaCategoria.ItemDaCategoriaId>;
  marcador?: FieldFilterExpression<domain.Marcador>;
  paraMim?: FieldFilterExpression<boolean>;
  periodo?: FieldFilterExpression<Periodo>;
  quantidadeDeDiasAnteriores?: FieldFilterExpression<number>;
  searchBy?: FieldFilterExpression<string>;
  documentosIgnorados?: FieldFilterExpression<domain.documento.DocumentoId[]>;
}

export type DocumentoComConfiguracao = {
  documento: domain.documento.Documento;
  configuracaoDaAssinatura: domain.configuracaoDaAssinatura.ConfiguracaoDaAssinatura;
  preview: domain.documento.DocumentoPreview;
};
```

ðŸ’¡ EspecificaÃ§Ã£o da query

```typescript
import { CollectionQuery } from "@3tecnos/cqs";
import { Serializable } from "@3tecnos/serialization";
import domain from "assine-aqui/domain";
import { listaDeDocumentosDTO } from "assine-aqui/shared";

@Serializable("GSn-Yz1fxcTYtGyH60DV7")
export class DocumentosQuery extends CollectionQuery<
  listaDeDocumentosDTO.DocumentoComConfiguracao,
  listaDeDocumentosDTO.DocumentosFilters
> {
  validate(): void {
    this.isValidInstance(this.filters.pendente, domain.documento.Pendente);
    this.isValidInstance(this.filters.itemDaCategoriaId, domain.itemDaCategoria.ItemDaCategoriaId);
    this.isValidInstance(this.filters.paraMim, "boolean");
    this.isValidInstance(this.filters.quantidadeDeDiasAnteriores, "number");
    this.isValidInstance(this.filters.searchBy, "string");
  }
}
```

ðŸ’¡ ImplementaÃ§Ã£o da query

```typescript
import { CollectionQueryResult } from "@3tecnos/cqs";
import { BaseQueryHandler, QueryHandler } from "@3tecnos/cqs-handlers";
import { ObterListaDeDocumentosService } from "assine-aqui-api/application";
import { autenticacaoDTO, listaDeDocumentosDTO } from "assine-aqui/shared";
import { queries } from "assine-aqui/shared";

@QueryHandler({
  for: queries.documento.DocumentosQuery,
  roles: [autenticacaoDTO.Roles.Root, autenticacaoDTO.Roles.Administrador, autenticacaoDTO.Roles.Assinante],
})
export class DocumentosQueryHandler extends BaseQueryHandler<queries.documento.DocumentosQuery> {
  constructor(private readonly service: ObterListaDeDocumentosService) {
    super();
  }

  async handle(
    query: queries.documento.DocumentosQuery
  ): Promise<CollectionQueryResult<listaDeDocumentosDTO.DocumentoComConfiguracao>> {
    const filters = query.filters;
    const pagination = query.pagination;

    const result = await this.service.handle({ filters, pagination });

    return {
      result: result.listaDeDocumentos,
      pagination: result.pagination,
    };
  }
}
```

ðŸ’¡ Service _ObterListaDeDocumentosService_

```typescript
import { IApplicationService } from "@3tecnos/arch/application";
import { DocGrid, PreviewInput } from "@3tecnos/docgrid";
import { OperationConflictException } from "@3tecnos/exceptions";
import { Injectable } from "@3tecnos/ioc";
import { getWhereByFilters } from "@3tecnos/no-sql";
import { currentDate, dateAdd, throwIfNullable } from "@3tecnos/util";
import { CNPJ, Pagination, UF } from "@3tecnos/values";
import {
  AssinantePrincipal,
  AssineAquiContext,
  CategoriaRepository,
  ConfiguracaoDaAssinaturaRepository,
  DocumentoDocument,
  UnidadeGestoraRepository,
} from "assine-aqui-api/infra";
import domain from "assine-aqui/domain";
import { autenticacaoDTO, listaDeDocumentosDTO } from "assine-aqui/shared";

type ObterListaDeDocumentosServiceInput = {
  filters: Partial<listaDeDocumentosDTO.DocumentosFilters>;
  pagination: Pagination;
};

type ObterListaDeDocumentosServiceOutput = {
  listaDeDocumentos: listaDeDocumentosDTO.DocumentoComConfiguracao[];
  pagination: Pagination;
};

type DocumentoPreviewInput = {
  categorias: domain.categoria.Categoria[];
  documento: domain.documento.Documento;
  cnpj: CNPJ;
  uf: UF;
};

@Injectable()
export class ObterListaDeDocumentosService
  implements IApplicationService<ObterListaDeDocumentosServiceInput, ObterListaDeDocumentosServiceOutput>
{
  constructor(
    private readonly dbContext: AssineAquiContext,
    private readonly princial: AssinantePrincipal,
    private readonly configuracaoDaAssinaturaRepository: ConfiguracaoDaAssinaturaRepository,
    private readonly unidadeGestoraRepository: UnidadeGestoraRepository,
    private readonly categoriaRepository: CategoriaRepository,
    private readonly docGrid: DocGrid
  ) {}

  private obterPreviewDoDocumento({
    categorias,
    uf,
    cnpj,
    documento,
  }: DocumentoPreviewInput): domain.documento.DocumentoPreview {
    if (documento.previewURL) {
      const { previewURL, nomeDoArquivo: fileName } = documento;
      return { URL: previewURL.value, fileName };
    }

    const categoriaDoDocumento = categorias.find((c) => c.id.equals(documento.categoriaId));
    const itemDaCategoria = categoriaDoDocumento?.obterItemDaCategoriaPorId(documento.itemDaCategoriaId.value);
    throwIfNullable(itemDaCategoria, OperationConflictException);
    const { relatorioPayload } = itemDaCategoria.export();
    const previewInput = {
      uf: uf.value,
      cnpj: cnpj.value,
      ano: documento.emissao.value.getFullYear().toString(),
      keys: documento.keys,
      relatorioPayload,
    } as PreviewInput;
    const URL = this.docGrid.generatePreviewURL(previewInput);
    return {
      fileName: documento.nomeDoArquivo,
      URL,
    };
  }

  private documentToEntity = (document: DocumentoDocument) =>
    new domain.documento.Documento({
      id: document.id,
      createdAt: document.createdAt!,
      categoriaId: document.categoriaId!,
      itemDaCategoriaId: document.itemDaCategoriaId!,
      autenticacao: document.autenticacao,
      pendente: document.pendente,
      unidadeGestoraId: document.unidadeGestoraId,
      keys: document.keys,
      assinaturas: document.assinaturas.map((assinatura) => ({
        cpf: assinatura.cpf,
        nome: assinatura.nome,
        ordem: assinatura.ordem,
        createdAt: assinatura.createdAt,
      })),
      resumo: document.resumo!,
      nome: document.nome!,
      interessado: document.interessado!,
      marcador: document.marcador!,
      descricao: document.descricao!,
      emissao: document.emissao!,
      proximosAssinantesCPFs: document.proximosAssinantesCPFs!,
      situacao: document.situacao!,
      previewURL: document.previewURL,
    });

  async handle({
    filters,
    pagination,
  }: ObterListaDeDocumentosServiceInput): Promise<ObterListaDeDocumentosServiceOutput> {
    const { cpf, cnpj } = this.princial.claims;
    const unidadeGestora = await this.unidadeGestoraRepository.findBy(cnpj);
    throwIfNullable(unidadeGestora, OperationConflictException);

    const role = this.princial.roles?.[0] as autenticacaoDTO.Roles;
    const { itemDaCategoriaId, periodo, quantidadeDeDiasAnteriores, pendente, documentosIgnorados, situacao } = filters;

    const perfilDeAdmin = role === "Root" || role === "Administrador";
    const perfilDeAssinante = role === "Assinante";

    const paraMim = filters.paraMim?.value ?? perfilDeAssinante;

    const configuracoesDasAssinaturas = await this.configuracaoDaAssinaturaRepository
      .withParentsIds(unidadeGestora.id.value)
      .find();

    const configuracoesDasAssinaturasDoAssinante = perfilDeAdmin
      ? configuracoesDasAssinaturas
      : configuracoesDasAssinaturas.filter((configuracao) => !!configuracao.obterAssinantePor(cpf));

    const itemDaCategoriaIdsDoAssinante = itemDaCategoriaId
      ? [itemDaCategoriaId.value.value]
      : configuracoesDasAssinaturasDoAssinante.map(({ itemDaCategoriaId }) => itemDaCategoriaId.value);

    if (itemDaCategoriaIdsDoAssinante.length === 0)
      return {
        listaDeDocumentos: [],
        pagination: new Pagination({ ...pagination, total: 0 }),
      };

    const querySearch = this.dbContext.documentoSearch.collection
      .whereEqualTo("unidadeGestoraId", unidadeGestora.id.value) //FIXME: implementar o withParentsIds para o algolia
      .where(
        getWhereByFilters<
          DocumentoDocument & {
            paraMim: boolean;
            periodo: listaDeDocumentosDTO.Periodo;
            quantidadeDeDiasAnteriores: number;
            documentosIgnorados?: domain.documento.DocumentoId[];
          }
        >(filters, {
          exclude: [
            "itemDaCategoriaId",
            "paraMim",
            "periodo",
            "quantidadeDeDiasAnteriores",
            "pendente",
            "documentosIgnorados",
          ],
        })
      )
	  .whereIn("itemDaCategoriaId", itemDaCategoriaIdsDoAssinante);

    if (pendente?.value) {
    if (pendente?.value) {
      //Documentos pendentes
      if (pendente.value.value) {
        querySearch.whereEqualTo("pendente", true);
        querySearch.whereEqualTo("situacao", domain.documento.SituacaoType.Pendente);
        if (paraMim) querySearch.whereEqualTo("proximosAssinantesCPFs", cpf.value);
      }
      //Documentos assinados
      else {
        if (paraMim) querySearch.whereEqualTo("assinaturasCPFs", cpf.value);
        else querySearch.whereEqualTo("pendente", false);
      }
    }
    else if (situacao?.value) {
      if (situacao.value.value === "Pendente") {
        querySearch.whereEqualTo("situacao", domain.documento.SituacaoType.Pendente);
        if (paraMim) querySearch.whereEqualTo("proximosAssinantesCPFs", cpf.value);
      } else if (situacao.value.value === "Assinado") {
        if (paraMim) querySearch.whereEqualTo("assinaturasCPFs", cpf.value);
        else querySearch.whereEqualTo("situacao", domain.documento.SituacaoType.Assinado);
      } else if (situacao.value.value === "Descartado") {
        querySearch.whereEqualTo("situacao", domain.documento.SituacaoType.Descartado);
      }
    }

    if (quantidadeDeDiasAnteriores) {
      querySearch.whereGreaterOrEqualThan(
        "emissao",
        dateAdd(currentDate(), "day", -1 * quantidadeDeDiasAnteriores.value)
      );
    } else if (periodo) {
      querySearch
        .whereGreaterOrEqualThan("emissao", periodo.value.inicio)
        .whereLessOrEqualThan("emissao", periodo.value.fim);
    }

    if (documentosIgnorados?.value && documentosIgnorados.value.length > 0) {
      const documentosASeremIgnorados = documentosIgnorados.value.map((documento) => documento.value);
      querySearch.whereNotIn("id", documentosASeremIgnorados);
    }

    const documentosDocument = await querySearch
      .orderByDescending("emissao")
      .limit(pagination.limit)
      .offSet(pagination.offset)
      .find();

    const categoriasIds = [...new Set(documentosDocument.map((doc) => doc.categoriaId!))];

    const categorias = await Promise.all(
      categoriasIds.map(async (categoriaId) => {
        const categoria = await this.categoriaRepository.findById(categoriaId);
        throwIfNullable(categoria, OperationConflictException);
        return categoria;
      })
    );

    const result: listaDeDocumentosDTO.DocumentoComConfiguracao[] = [];

    documentosDocument.forEach((document) => {
      const documento = this.documentToEntity(document);

      const configuracaoDaAssinatura = configuracoesDasAssinaturasDoAssinante.find((configuracao) =>
        configuracao.itemDaCategoriaId.equals(documento.itemDaCategoriaId)
      );
      throwIfNullable(configuracaoDaAssinatura, OperationConflictException);

      const preview = this.obterPreviewDoDocumento({
        categorias,
        documento,
        uf: new UF(unidadeGestora.uf),
        cnpj: unidadeGestora.cnpj,
      });
      result.push({
        documento,
        configuracaoDaAssinatura,
        preview,
      });
    });

    return {
      listaDeDocumentos: result,
      pagination: new Pagination({ ...pagination, total: result.length }),
    };
  }
}
```

ðŸ’¡ Query _CategoriasQueryHandler_

ðŸ’¡ Tipos/interfaces compartilhadas para a query

```typescript
import domain from "assine-aqui/domain";

export type CategoriaOutput = domain.categoria.Categoria;
```

```typescript
import { CollectionQueryResult } from "@3tecnos/cqs";
import { BaseQueryHandler, QueryHandler } from "@3tecnos/cqs-handlers";
import { Pagination } from "@3tecnos/values";
import { ObterListaDeCategoriasService } from "assine-aqui-api/application";
import { autenticacaoDTO, listaDeCategoriasDTO } from "assine-aqui/shared";
import { queries } from "assine-aqui/shared";

@QueryHandler({
  for: queries.categoria.CategoriasQuery,
  roles: [autenticacaoDTO.Roles.Root, autenticacaoDTO.Roles.Administrador, autenticacaoDTO.Roles.Assinante],
})
export class CategoriasQueryHandler extends BaseQueryHandler<queries.categoria.CategoriasQuery> {
  constructor(private readonly service: ObterListaDeCategoriasService) {
    super();
  }

  async handle(): Promise<CollectionQueryResult<listaDeCategoriasDTO.CategoriaOutput>> {
    const { categorias } = await this.service.handle();

    return {
      result: categorias,
      pagination: new Pagination(),
    };
  }
}
```

ðŸ’¡ Service _ObterListaDeCategoriasService_

```typescript
import { IApplicationService } from "@3tecnos/arch/application";
import { Injectable } from "@3tecnos/ioc";
import { autenticacaoDTO, listaDeCategoriasDTO } from "assine-aqui/shared";
import {
  ConfiguracaoDaAssinaturaRepository,
  UnidadeGestoraRepository,
  AssinantePrincipal,
  AssineAquiContext,
} from "assine-aqui-api/infra";
import domain from "assine-aqui/domain";
import { sortByKey, throwIfNullable } from "@3tecnos/util";
import { OperationConflictException } from "@3tecnos/exceptions";

type ObterListaDeCategoriasServiceOutput = {
  categorias: listaDeCategoriasDTO.CategoriaOutput[];
};

@Injectable()
export class ObterListaDeCategoriasService implements IApplicationService<void, ObterListaDeCategoriasServiceOutput> {
  constructor(
    private readonly princial: AssinantePrincipal,
    private readonly dbContext: AssineAquiContext,
    private readonly configuracaoDaAssinaturaRepository: ConfiguracaoDaAssinaturaRepository,
    private readonly unidadeGestoraRepository: UnidadeGestoraRepository
  ) {}

  async handle(): Promise<ObterListaDeCategoriasServiceOutput> {
    const { cpf, cnpj } = this.princial.claims;
    const unidadeGestora = await this.unidadeGestoraRepository.findBy(cnpj);
    throwIfNullable(unidadeGestora, OperationConflictException);

    const role = this.princial.roles?.[0] as autenticacaoDTO.Roles;

    const perfilDeAdmin = role === "Root" || role === "Administrador";

    const configuracoesDasAssinaturas = await this.configuracaoDaAssinaturaRepository
      .withParentsIds(unidadeGestora.id.value)
      .find();

    const configuracoesDoAssinante = perfilDeAdmin
      ? configuracoesDasAssinaturas
      : configuracoesDasAssinaturas.filter((configuracao) => !!configuracao.obterAssinantePor(cpf));

    const itemDaCategoriaIdsDoAssinante = configuracoesDoAssinante.map(
      ({ itemDaCategoriaId }) => itemDaCategoriaId.value
    );

    const todasAsCategorias = await this.dbContext.categoria.collection.orderByAscending("nome").find();

    const categoriasDoAssinante: listaDeCategoriasDTO.CategoriaOutput[] = [];

    todasAsCategorias.forEach((categoria) => {
      const itens = categoria.itens.filter(({ id }) => itemDaCategoriaIdsDoAssinante.includes(id));
      if (itens?.length > 0) {
        const itensOrdenados = sortByKey(itens, "nome");
        categoriasDoAssinante.push(
          new domain.categoria.Categoria({
            id: categoria.id,
            createdAt: categoria.createdAt!,
            nome: categoria.nome!,
            itens: itensOrdenados,
          })
        );
      }
    });

    return {
      categorias: categoriasDoAssinante,
    };
  }
}
```
