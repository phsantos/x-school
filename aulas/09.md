,<p align="center">
<a href="#">
<img width="400" src="https://github.com/3Tecnos-Development/mono/assets/5139981/ec6daa7c-9107-46ae-9389-1e20e93cca39">
</a>

</p>
<h1 align="center" style="color:purple">X-School</h1>

<h1 align="center">Curso de Desenvolvimento Full Stack com Node.js, React Native e Monorepo NX (DDD e SOLID)</h1>

<h1 align="center">API e DDD</h1>

### Aula 09

#### Repository

O padrÃ£o Repository Ã© um padrÃ£o de projeto (design pattern) frequentemente utilizado no desenvolvimento de software para separar a lÃ³gica de acesso aos dados (armazenamento) da lÃ³gica de negÃ³cios. Ele fornece uma camada de abstraÃ§Ã£o entre o cÃ³digo que lida com a persistÃªncia de dados e o restante da aplicaÃ§Ã£o, permitindo que as operaÃ§Ãµes de leitura e gravaÃ§Ã£o sejam realizadas de maneira mais eficiente e coesa.

A relaÃ§Ã£o entre o padrÃ£o Repository e o Domain-Driven Design (DDD) Ã© significativa, uma vez que o DDD enfatiza a criaÃ§Ã£o de um modelo de domÃ­nio rico e bem encapsulado, enquanto o padrÃ£o Repository facilita o acesso a esse modelo de domÃ­nio por meio de operaÃ§Ãµes de persistÃªncia.

CaracterÃ­sticas:

1. SeparaÃ§Ã£o de Responsabilidades
   > [!NOTE] <span style="color:purple"> O DDD prega a separaÃ§Ã£o de responsabilidades e a criaÃ§Ã£o de um modelo de domÃ­nio que reflete o negÃ³cio da aplicaÃ§Ã£o. O padrÃ£o Repository ajuda a separar as preocupaÃ§Ãµes relacionadas Ã  persistÃªncia dos objetos do domÃ­nio, permitindo que as entidades e agregados do domÃ­nio sejam tratados independentemente do mecanismo de armazenamento.
2. AbstraÃ§Ã£o do Acesso aos Dados
   > [!NOTE] <span style="color:purple"> O Repository atua como uma abstraÃ§Ã£o entre o domÃ­nio e os detalhes de acesso aos dados. Isso significa que o modelo de domÃ­nio nÃ£o precisa saber como os dados sÃ£o armazenados, e as operaÃ§Ãµes de acesso aos dados sÃ£o encapsuladas no Repository.
3. Encapsulamento
   > [!NOTE] <span style="color:purple"> O DDD promove o encapsulamento dos conceitos do domÃ­nio, tornando-os independentes de detalhes tÃ©cnicos. O Repository fornece uma interface para interagir com esses conceitos encapsulados, garantindo que a lÃ³gica de persistÃªncia nÃ£o contamine o modelo de domÃ­nio.
4. Agregados e Entidades
   > [!NOTE] <span style="color:purple"> O DDD enfatiza a definiÃ§Ã£o de agregados e entidades, que sÃ£o componentes fundamentais do modelo de domÃ­nio. O Repository Ã© usado para carregar e persistir esses agregados e entidades.
5. Camada de Infraestrutura
   > [!NOTE] <span style="color:purple"> A implementaÃ§Ã£o concreta do Repository geralmente reside na camada de infraestrutura do sistema. Isso ajuda a manter a camada de domÃ­nio pura e livre de detalhes tÃ©cnicos.
6. ConsistÃªncia do Modelo
   > [!NOTE] <span style="color:purple"> O Repository ajuda a manter a consistÃªncia do modelo de domÃ­nio ao garantir que as operaÃ§Ãµes de persistÃªncia sejam tratadas de forma adequada, cumprindo as regras de validaÃ§Ã£o e integridade definidas no domÃ­nio.

##### Vejamos alguns exemplos:

ðŸ’¡ Document _UnidadeGestoraDocument_

```typescript
import { Collection, IDocument } from "@3tecnos/no-sql";
import { UF as UFType } from "@3tecnos/util";

type Municipio = {
  codigoIBGE: number;
  nome: string;
  uf: UFType;
};

@Collection({ path: "unidadesGestoras" })
export class UnidadeGestoraDocument implements IDocument {
  id: string = "";
  createdAt: Date | null = null;
  cnpj: string | null = null;
  nome: string | null = null;
  municipio: Municipio | null = null;
}
```

ðŸ’¡ Document _DocumentoDocument_

```typescript
import { Collection, IDocument } from "@3tecnos/no-sql";
import { UnidadeGestoraDocument } from "./unidade-gestora-document";
import domain from "assine-aqui/domain";

@Collection({ path: "documentos", searchIndex: "unidadesGestorasDocumentos", parent: UnidadeGestoraDocument })
export class DocumentoDocument implements IDocument {
  id: string = "";
  unidadeGestoraId: string = "";
  autenticacao: string = "";
  assinaturas: domain.documento.AssinaturaProps[] = [];
  categoriaId: string | null = null;
  itemDaCategoriaId: string | null = null;
  pendente: boolean = true;
  createdAt: Date | null = null;
  keys: string[] = [];
  keysString: string = "";
  emissao: Date | null = null;
  nome: string | null = null;
  interessado: string | null = null;
  marcador: string | null = null;
  descricao: string | null = null;
  resumo: Record<number, Record<string, string>> | null = null;
  assinaturasCPFs: string[] = [];
  totalDeAssinaturas: number = 0;
  proximosAssinantesCPFs: string[] = [];
  situacao: domain.documento.SituacaoType | null = null;
  previewURL: string | null = null;
}
```

ðŸ’¡ DbContext _AssineAquiContext_

```typescript
import { Injectable } from "@3tecnos/ioc";
import { BaseDbContext } from "@3tecnos/no-sql";
import { Memoize } from "@boost/decorators";
import { CategoriaDocument } from "../documents/categoria-document";
import { ConfiguracaoDaAssinaturaDocument } from "../documents/configuracao-da-assinatura-document";
import { DocumentoDocument } from "../documents/documento-document";
import { UnidadeGestoraDocument } from "../documents/unidade-gestora-document";

@Injectable()
export class AssineAquiContext extends BaseDbContext {
  ...

  @Memoize()
  get documento() {
    return this.createPersistance(DocumentoDocument);
  }

  @Memoize()
  get documentoSearch() {
    return this.createPersistance(DocumentoDocument, true);
  }

  @Memoize()
  get unidadeGestora() {
    return this.createPersistance(UnidadeGestoraDocument);
  }

  ...
}

```

ðŸ’¡ Repository _UnidadeGestoraRepository_

```typescript
import { Injectable } from "@3tecnos/ioc";
import { BaseRepository } from "../base-repository";
import { RepositoryConfigBuilder } from "@3tecnos/no-sql";
import { UnidadeGestoraDocument } from "../../documents/unidade-gestora-document";
import domain from "assine-aqui/domain";
import { CNPJ } from "@3tecnos/values";

type MapDocumentToEntityProps = {
  unidadeGestora: UnidadeGestoraDocument;
};

@Injectable()
export class UnidadeGestoraRepository extends BaseRepository<
  domain.unidadeGestora.UnidadeGestora,
  MapDocumentToEntityProps
> {
  protected mapToEntity({ unidadeGestora }: MapDocumentToEntityProps): domain.unidadeGestora.UnidadeGestora {
    return new domain.unidadeGestora.UnidadeGestora(this.makeEntityProps({ unidadeGestora }));
  }

  protected onRepositoryCreating(
    configBuilder: RepositoryConfigBuilder<MapDocumentToEntityProps>
  ): RepositoryConfigBuilder {
    return configBuilder.withRoot(this.dbContext.unidadeGestora, "unidadeGestora");
  }

  public async findBy(unidadeGestoraCnpj: CNPJ): Promise<domain.unidadeGestora.UnidadeGestora | null> {
    const { cnpj } = unidadeGestoraCnpj.export();
    const document = await this.dbContext.unidadeGestora.collection.whereEqualTo("cnpj", cnpj).findOne();
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const documentInput = { unidadeGestora: document! };

    if (document) {
      return this.mapToEntity(documentInput as MapDocumentToEntityProps);
    }

    return null;
  }

  protected makeEntityProps({ unidadeGestora }: MapDocumentToEntityProps): domain.unidadeGestora.UnidadeGestoraProps {
    return {
      id: unidadeGestora.id,
      createdAt: unidadeGestora.createdAt!,
      cnpj: unidadeGestora.cnpj!,
      nome: unidadeGestora.nome!,
      municipio: unidadeGestora.municipio!,
    };
  }
}
```

ðŸ’¡ Repository _DocumentoRepository_

```typescript
import { Injectable } from "@3tecnos/ioc";
import { BaseRepository } from "../base-repository";
import { RepositoryConfigBuilder } from "@3tecnos/no-sql";
import { DocumentoDocument } from "../../documents/documento-document";
import domain from "assine-aqui/domain";
import { isString } from "@3tecnos/util";

type MapDocumentToEntityProps = {
  documento: DocumentoDocument;
};

@Injectable()
export class DocumentoRepository extends BaseRepository<domain.documento.Documento, MapDocumentToEntityProps> {
  protected mapToEntity({ documento }: MapDocumentToEntityProps): domain.documento.Documento {
    return new domain.documento.Documento(this.makeEntityProps({ documento }));
  }

  private obterCPFsDasAssinaturas(documento: DocumentoDocument) {
    return documento.assinaturas.map((assinatura) => assinatura.cpf);
  }
  private obterTotalDeAssinaturas(documento: DocumentoDocument) {
    return documento.assinaturas.length;
  }
  private keysToString(documento: DocumentoDocument) {
    return documento.keys.join("");
  }

  protected onRepositoryCreating(
    configBuilder: RepositoryConfigBuilder<MapDocumentToEntityProps>
  ): RepositoryConfigBuilder {
    return configBuilder
      .withRoot(this.dbContext.documento, "documento")
      .replicate("documento", this.obterCPFsDasAssinaturas, "assinaturasCPFs")
      .replicate("documento", this.obterTotalDeAssinaturas, "totalDeAssinaturas")
      .replicate("documento", this.keysToString, "keysString");
  }

  protected makeEntityProps({ documento }: MapDocumentToEntityProps): domain.documento.DocumentoProps {
    return {
      id: documento.id,
      unidadeGestoraId: documento.unidadeGestoraId!,
      createdAt: documento.createdAt!,
      categoriaId: documento.categoriaId!,
      itemDaCategoriaId: documento.itemDaCategoriaId!,
      assinaturas: documento.assinaturas!,
      autenticacao: documento.autenticacao!,
      pendente: documento.pendente!,
      keys: documento.keys!,
      emissao: documento.emissao!,
      nome: documento.nome!,
      interessado: documento.interessado!,
      marcador: documento.marcador!,
      descricao: documento.descricao!,
      resumo: documento.resumo!,
      proximosAssinantesCPFs: documento.proximosAssinantesCPFs!,
      situacao: documento.situacao!,
      previewURL: documento.previewURL!,
    };
  }

  async findOneByKeys(
    itemDaCategoriaId: domain.itemDaCategoria.ItemDaCategoriaId,
    keys: ReadonlyArray<string> | string
  ): Promise<domain.documento.Documento | null> {
    const documento = await this.dbContext.documento.collection
      .whereEqualTo("itemDaCategoriaId", itemDaCategoriaId.value)
      .whereEqualTo("keysString", isString(keys) ? keys : keys.join(""))
      .findOne();

    if (documento) {
      const documentInput = { documento };
      return this.mapToEntity(documentInput as MapDocumentToEntityProps);
    }

    return null;
  }

  async findBy(
    itemDaCategoriaId: domain.itemDaCategoria.ItemDaCategoriaId,
    pendente: domain.documento.Pendente
  ): Promise<domain.documento.Documento[] | null> {
    const documentos = await this.dbContext.documento.collection
      .whereEqualTo("itemDaCategoriaId", itemDaCategoriaId.value)
      .whereEqualTo("pendente", pendente.value)
      .find();
    return await this.buildEntitiesFrom(documentos);
  }
}
```
