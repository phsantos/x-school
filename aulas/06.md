,<p align="center">
<a href="#">
<img width="400" src="https://github.com/3Tecnos-Development/mono/assets/5139981/ec6daa7c-9107-46ae-9389-1e20e93cca39">
</a>

</p>
<h1 align="center" style="color:purple">X-School</h1>

<h1 align="center">Curso de Desenvolvimento Full Stack com Node.js, React Native e Monorepo NX (DDD e SOLID)</h1>

<h1 align="center">API e DDD</h1>

### Aula 06

#### Controller

Em uma arquitetura de desenvolvimento de APIs, um "Controller" Ã© uma camada responsÃ¡vel por receber as requisiÃ§Ãµes HTTP (como GET, POST, PUT, DELETE) dos clientes (geralmente navegadores ou outros sistemas) e direcionÃ¡-las para a lÃ³gica de negÃ³cios apropriada. Os Controllers sÃ£o responsÃ¡veis por interpretar os parÃ¢metros da requisiÃ§Ã£o, chamar os serviÃ§os ou mÃ©todos adequados e, em seguida, retornar uma resposta HTTP apropriada para o cliente.

A relaÃ§Ã£o entre um Controller em uma API e o DDD:

CaracterÃ­sticas:

1. SeparaÃ§Ã£o de Responsabilidades:
   > [!NOTE] <span style="color:purple"> Em uma arquitetura de desenvolvimento de APIs, um "Controller" Ã© uma camada responsÃ¡vel por receber as requisiÃ§Ãµes HTTP (como GET, POST, PUT, DELETE) dos clientes (geralmente navegadores ou outros sistemas) e direcionÃ¡-las para a lÃ³gica de negÃ³cios apropriada. Os Controllers sÃ£o responsÃ¡veis por interpretar os parÃ¢metros da requisiÃ§Ã£o, chamar os serviÃ§os ou mÃ©todos adequados e, em seguida, retornar uma resposta HTTP apropriada para o cliente.
2. Controllers e Casos de Uso
   > [!NOTE] <span style="color:purple"> No contexto do DDD, os Controllers podem ser vistos como a ponte entre a interface do usuÃ¡rio (UI) ou os clientes externos e os casos de uso do domÃ­nio. Os Controllers interpretam as requisiÃ§Ãµes dos clientes e, em seguida, invocam os serviÃ§os e mÃ©todos de aplicaÃ§Ã£o que representam os casos de uso de negÃ³cios definidos pelo DDD.
3. ValidaÃ§Ã£o e Tratamento de RequisiÃ§Ãµes
   > [!NOTE] <span style="color:purple"> Os Controllers sÃ£o responsÃ¡veis por validar os dados recebidos nas requisiÃ§Ãµes e transformÃ¡-los em formatos compreensÃ­veis para o domÃ­nio. Essa validaÃ§Ã£o muitas vezes reflete regras do domÃ­nio definidas no DDD.
4. Modelagem do DomÃ­nio
   > [!NOTE] <span style="color:purple"> O DDD ajuda a criar um modelo de domÃ­nio rico, que reflete as complexidades e nuances do negÃ³cio. Os Controllers, por sua vez, usam esse modelo para interagir com o domÃ­nio e realizar operaÃ§Ãµes relevantes.

##### Vejamos alguns exemplos:

ðŸ’¡ Controller _CriarServidorController_ Com inputs

ðŸ’¡ Tipos/interfaces compartilhadas para o controller

```typescript
import domain from "x-school/domain";

export type CriarServidorInput = Omit<domain.servidor.ServidorProps, "id" | "createdAt"> & {
  cnpj: string;
};

export type CriarServidorOutput = {
  id: domain.servidor.ServidorId;
  createdAt: string;
};
```

```typescript
import { BaseController, PostController, type ControllerWithInput } from "@3tecnos/node-express";
import { CriarServidorService } from "x-school/api/application";
import { servidorDTO } from "x-school/shared";

@PostController({ path: "/servidores" })
export class CriarServidorController
  extends BaseController<servidorDTO.CriarServidorOutput>
  implements ControllerWithInput<servidorDTO.CriarServidorInput>
{
  constructor(private readonly criarServidorService: CriarServidorService) {
    super();
  }

  parseInput(): servidorDTO.CriarServidorInput {
    const input = this.rawInput as servidorDTO.CriarServidorInput;
    return input;
  }

  async handle(): Promise<servidorDTO.CriarServidorOutput> {
    const input = this.parseInput();
    return this.criarServidorService.handle({ ...input });
  }
}
```

ðŸ’¡ Controller _AlterarServidorController_ Com inputs e params

ðŸ’¡ Tipos/interfaces compartilhadas para o controller

```typescript
import domain from "x-school/domain";

export type AlterarServidorInput = Omit<domain.servidor.ServidorProps, "id"> & {
  cnpj: string;
};

export type AlterarServidorParams = {
  servidorId: domain.servidor.ServidorId;
};
```

```typescript
import { BaseController, type ControllerWithInput, ControllerWithParams, PutController } from "@3tecnos/node-express";
import { CriarServidorService } from "x-school/api/application";
import domain from "x-school/domain";
import { servidorDTO } from "x-school/shared";

@PutController({ path: "servidores/:servidorId" })
export class AlterarServidorController
  extends BaseController
  implements
    ControllerWithParams<servidorDTO.AlterarServidorParams>,
    ControllerWithInput<servidorDTO.AlterarServidorInput>
{
  constructor(private readonly alterarServidorService: AlterarServidorService) {
    super();
  }

  parseParams(): servidorDTO.AlterarServidorParams {
    const servidorId = new domain.servidor.ServidorId(this.rawParams["servidorId"] ?? "");
    return {
      servidorId,
    };
  }

  parseInput(): servidorDTO.AlterarServidorInput {
    const input = this.rawInput as servidorDTO.AlterarServidorInput;

    const servidor = domain.Servidor.criar({ ...input });

    return input;
  }

  async handle(): Promise<void> {
    const body = this.parseInput();
    const params = this.parseParams();

    const input = {
      servidorId: params.servidorId,
      ...body,
    };
    return this.alterarServidorService.handle({ ...input });
  }
}
```
